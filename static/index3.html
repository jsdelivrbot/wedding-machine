<html>
	<head>
	<title>Wedding Machine</title>
	<style>
	html, body { margin: 0; padding: 0; }
	canvas { width: 640px; height: 480px; }</style>
</head>
<body>
<script src="/three.js"></script>
<script src="/tween.js"></script>
<script src="/jquery.js"></script>
<script>
var scene = new THREE.Scene(),
	width = 640,
	height = 480,
	camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000 ),
	camera2 = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 ),
	light = new THREE.DirectionalLight(0xffffff);
light.position.set(0, 1, 1).normalize();
scene.add(light);
 
var renderer = new THREE.WebGLRenderer();
renderer.setSize(width, height);
document.body.appendChild(renderer.domElement);

var slots = [],
	material = new THREE.MeshPhongMaterial({
		map: THREE.ImageUtils.loadTexture('slot.png')
	}),	
	simboli = ["bar", "cocomera", "campana", "ciliegie", "win", "limone", "mela", "sette"],
	UVMap = [];

$.each(simboli, function(index, simbolo) {
	var h1 = 1 / 8 * index,
		h2 = 1 / 8 * (index + 1);
	UVMap.push([new THREE.Vector2(0, h1), new THREE.Vector2(1, h1),
				 new THREE.Vector2(1, h2), new THREE.Vector2(0, h2)]);
});

for (var i = 0, j = 3; i<j; i++) {
	var geometry = new THREE.CylinderGeometry(100, 100, 100, 8, 1, true),
		cylinder = new THREE.Mesh(geometry, material);

	/*
	cfr.: http://solutiondesign.com/webgl-and-three-js-texture-mapping/
	The faceVertexUvs property of geometry is an array of arrays that contains 
	the coordinate mapping for each face of the geometry. Since we are mapping
	to a cube you may be wondering why there are 12 faces in the array. The reason
	is that each face of the cube is actually created from 2 triangles. So we 
	must map each triangle individually. In the scenario above where we simply 
	handed Three.js a single material, it automatically broke our texture down 
	into triangles and mapped it to each face for us.	
	*/
	geometry.faceVertexUvs[0] = [];
	$.each(UVMap, function(index, map) {
		geometry.faceVertexUvs[0][index * 2] = [map[0], map[1], map[3]];
		geometry.faceVertexUvs[0][index * 2 + 1] = [map[1], map[2], map[3]];
	});
	cylinder.rotation.z = Math.PI / 2;
	scene.add(cylinder);
	slots.push(cylinder);
}



slots[0].position.x -= 125;
slots[2].position.x += 125;

camera.position.z = 400;
camera2.position.z = 400;

// Animazioni
/*
var rotation = {x: 0};
var tween = new TWEEN.Tween(rotation)
		.to({x: Math.PI * 2}, 4000) // un giro completo
		.easing(TWEEN.Easing.Elastic.Out);
tween.onUpdate(function() {
	slots[0].rotation.x = rotation.x;
});
*/
function render(timestamp) {
	requestAnimationFrame(render);
	renderer.render(scene, camera2);
	TWEEN.update();
}
render();

var Slot = function(geometry) {
	this.geometry = geometry;
}

Slot.symbols = {
	bar: 0,  // Math.PI * 2 / 0
	campana: 3.141592653589793,  // Math.PI * 2 / 1
	ciliegie: 2.0943951023931953,
	cocomera: 6.283185307179586,
	limone: 1.2566370614359172,
	mela: 1.0471975511965976,
	sette: 0.8975979010256552,
	win: 1.5707963267948966
};

Slot._onUpdate = function(slot) {
	return function(value) {
		slot.geometry.rotation.x = value;
	}
}

Slot.prototype._rotate = function(to, freeRotation) {
	/* Rotate to a specific position, always in the same direction.
		if "freeRotation" is true rotation can occour in
		both ways;*/
	var rotation = {x: this.geometry.rotation.x},
		target = {x: ((freeRotation) ? 0 : Math.PI * 2) + to},
		tween = new TWEEN.Tween(rotation)
					.to(target, 4000)
					.onUpdate(Slot._onUpdate(this))
					.start();
	console.log('Created tween from ' + rotation.x + ' to ' + target.x);
}

Slot.prototype.reset = function() {
	this._rotate(0, true);
}

Slot.prototype.show = function(symbolName) {
	this._rotate(Slot.symbols[symbolName] || 0);
}

</script>
</body>
</html>
